---
title: "dpcR package - an overview"
author: "Micha&#322; Burdukiewicz, Stefan R&ouml;diger"
date: "2015-08-13"
output: 
  rmarkdown::html_vignette:
    toc: true
bibliography: "dpcr.bib"
vignette: >
  %\VignetteIndexEntry{dpcR package - an overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r eval=TRUE,echo=FALSE}
library(knitr)
opts_chunk$set(fig.width=6, fig.height=6)

library(ggplot2)
library(xtable)

size_mod <- -2
cool_theme <- theme(plot.background=element_rect(fill = "transparent",
                                                 colour = "transparent"),
                    panel.grid.major = element_line(colour="lightgrey", linetype = "dashed"),
                    panel.background = element_rect(fill = "white", colour = "black"),
                    legend.background = element_rect(fill="NA"),
                    legend.position = "bottom",
                    axis.text = element_text(size=12 + size_mod),
                    axis.title.x = element_text(size=15 + size_mod, vjust = -0.1), 
                    axis.title.y = element_text(size=15 + size_mod, vjust = 1),
                    strip.text = element_text(size=15 + size_mod, face = "bold"),
                    strip.background = element_rect(fill = "#9ecae1", colour = "black"),
                    legend.text = element_text(size=12 + size_mod), 
                    legend.title = element_text(size=15 + size_mod),
                    plot.title = element_text(size=20 + size_mod))

load("vig.RData")
```

dpcR is an R package designed to perform an analysis of digital PCR experiments.

# Read data

The `read_dpcr` function is responsible for importing data into R working space. The additional parameters allow specification of the format type.

Additionally, we advise using other packages belonging do the pcRuniversum such as [RDML](http://cran.r-project.org/package=RDML) or dedicated packages such as ReadqPCR ([available from bioconductor.org](http://www.bioconductor.org/packages/release/bioc/html/ReadqPCR.html)). Further information can be found in @pabinger_survey_2014.

Before analysis data should be saved using one of the three classes - `adpcr` (end-point array digital PCR experiments), `ddpcr` (droplet digital PCR experiments) and `rtadpcr` (real-time array digital PCR experiments). To do so, use `create_dpcr` function.

```{r eval=TRUE}
library(dpcR)
#generate some data from 15x16 array. Let's presume, that we have results from two plates
sample_runs <- matrix(rpois(480, lambda = 1.5), ncol = 2)
#check its class - it's a typical R structure
class(sample_runs)
#save it to adpcr object
adpcr_experiments <- create_dpcr(sample_runs, n = c(240L, 240L), type = "nm", adpcr = TRUE)
class(adpcr_experiments)
```

# Data visualisation

Data can be easily visualized using `plot_panel` function.

```{r eval=TRUE}
#remember, you can plot only single panel at once 
plot_panel(extract_dpcr(adpcr_experiments, 1), nx_a = 15, ny_a = 16, main = "Experiment 1")
```

The same data can be visualized easily in binarized form (positive/negative partitions).
```{r eval=TRUE}
#remember, you can plot only single panel at once 
plot_panel(binarize(extract_dpcr(adpcr_experiments, 1)), nx_a = 15, ny_a = 16, main = "Experiment 1")
```


# Comparison of the experiments

## GLM

Generalized Linear Models (GLM) are linear models for data, where the response variables may have non-normal distributions (as for example binomially distributed positive partitions in digital PCR experiments). Using GLM we can describe relationships between results of digital PCR:
  
  $$\log{Y} = \beta^T X$$
  
  where $Y$ are counts, $X$ are experiments names (categorical data) and $\beta$ are linear model coefficients for every experiment. Moreover, $\exp{\beta} = \lambda$.

Estimated means copies per partitions obtained from the model are compared each other using multiple t-test.

```{r eval=TRUE}
#compare experiments using GLM
#set a random seed for simulations
set.seed(54321)

#1. Simulate results of three different experiments with two repetitions each
#experiment 2 differs significantly from others
adpcr1 <- sim_adpcr(m = 20, n = 765, times = 1e5, pos_sums = FALSE, n_panels = 2)
adpcr2 <- sim_adpcr(m = 130, n = 765, times = 1e5, pos_sums = FALSE, n_panels = 2)
adpcr2 <- rename(adpcr2, exper = "Experiment2")
adpcr3 <- sim_adpcr(m = 50, n = 765, times = 1e5, pos_sums = FALSE, n_panels = 2)
adpcr3 <- rename(adpcr3, exper = "Experiment3")
#2. Join results for convenience
adpcrs <- bind_dpcr(adpcr1, adpcr2, adpcr3)

#3. Perform test
comp <- test_counts(adpcrs)

#4. See summary of the test
summary(comp)

#5. Plot results of the test 
plot(comp, aggregate = FALSE)

#6. Aggregate runs to their groups
plot(comp, aggregate = TRUE)

#7. extract coefficients for the further usage
coef(comp)
```

The Poisson regression on binary data (positive/negative partition) can be used only when the concentration of template molecules in samples is small (positive partitions contain very rarely more than 1 template particle). Higher concentrations requires binomial regression.

## Multiple tests

The dPCR experimentes may be also compared pairwise using the uniformly most powerful (UMP) ratio test [@fay_2010]. Furthermore, computed p-values are adjusted using Benjamini & Hochberg correction [@benjamini_1995] to control family-wise error rate.

The UMP ratio test has following null-hypothesis:

$$
H_0: \frac{\lambda_1}{\lambda_2} = 1
$$

The generally adviced Wilson's confidence intervals [@brown_2001] are computed independently for every dPCR experiment. The confidence intervals are adjusted using Dunn -- &#352;id&#225;k correction to ensure that they simultaneously contain true value of $lambda$:

$$
\alpha_{\text{adj}} = 1 - (1 - \alpha)^\frac{1}{T}
$$

For example, the 0.95 significance levels means, that probability of the all real values being in the range of its respective confidence intervals is 0.95.

```{r eval=TRUE}
#1. Perform multiple test comparison using data from the previous example
comp_ratio <- test_counts(adpcrs, model = "ratio")

#2. See summary of the test
summary(comp_ratio)

#3. Plot results of the test 
plot(comp_ratio, aggregate = FALSE)

#4. Aggregate runs to their groups
plot(comp_ratio, aggregate = TRUE)

#5. extract coefficients for the further usage
coef(comp)

#compare results of two methods
par(mfrow=c(2,1))
plot(comp, aggregate = FALSE)
title("GLM")
plot(comp_ratio, aggregate = FALSE)
title("Ratio")
par(mfrow=c(1,1))


```


## Comparision of frameworks
Two approaches presented above were compared in a simulation approach over 150 000 simulated array dPCR experiments. Each simulation contained six reactions. Three of them had roughly the same amount of molecules per plate and other three had experiments with 10 to 50 molecules more.
Experiments were compared using GLM and MT frameworks.

```{r eval=TRUE,echo=FALSE}
ggplot(data=madpcr_comp,aes(x = value, fill = method)) +
  geom_density(alpha = 0.3) + 
  scale_fill_discrete("Confidence intervals:") + 
  scale_y_continuous("Density") + 
  scale_x_continuous("Fraction of wrongly assigned experiments") + 
  cool_theme
```

On average, 2.03 and 1.98 reactions were assessed to a wrong group by respectively GLM and MT.

A single GLM comparison took roughly 183 times longer than MT (on average 1.10 seconds versus 0.006 seconds on the Intel i7-2600 processor). The difference growths with the number of experiments and number of partitions (data not shown).


## Probability coverage of confidence intervals

  Average covarage probability is the proportion of the time that the interval contains the true value of $\lambda$.
  
  In the example below, we simulated 1\e{6} droplet dPCR experiments (2\e{4} droplets each) for each level of $\lambda$ (1.2\e{7} experiments total). We computed average probability coverage of CI obtained by three methods: Dube's[@dube_mathematical_2008], Bhat's[@bhat_single_2009] and by MT ($\alpha = 0.95$).
  
  To assess simultaneous coverage probability, we randomly divided experiments into 2000 groups (500 experiments each) for each possible value of $\lambda$. We counted frequency of groups in which all confidence intervals contain the true value of $\lambda$.
  
  
```{r eval=TRUE,echo=FALSE}
ggplot(m_coverage2, aes(x = prop, y = value, fill = method)) +
  geom_bar(stat="identity", position = "dodge") +
  scale_y_continuous("Probability coverage") + 
  scale_x_discrete(expression(lambda)) +
  scale_fill_discrete("Confidence intervals:") + 
  geom_hline(y = 0.95, colour = "black", size = 1, linetype = 5) +
  facet_wrap(~ coverage, nrow = 2) + 
  cool_theme
```

The dashed black line marks 0.95 border.

```{r eval=TRUE,echo=FALSE,results="asis"}
dat <- as.data.frame(aggregate(value ~ method + coverage, m_coverage2, mean))

colnames(dat) <- c("Method name", "Type of coverage", "Value")
print(xtable(dat), 
      include.rownames = FALSE, type = "html")
```
  
  
# References
