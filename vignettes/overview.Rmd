---
title: "dpcR package - an overview"
author: "Micha&#322; Burdukiewicz, Stefan R&ouml;diger"
date: "2015-08-13"
output: 
  rmarkdown::html_vignette:
    toc: true
bibliography: "dpcr.bib"
vignette: >
  %\VignetteIndexEntry{dpcR package - an overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r eval=TRUE,echo=FALSE}
library(knitr)
opts_chunk$set(fig.width=6, fig.height=6)

library(ggplot2)
library(xtable)
library(dpcR)

size_mod <- -2
cool_theme <- theme(plot.background=element_rect(fill = "transparent",
                                                 colour = "transparent"),
                    panel.grid.major = element_line(colour="lightgrey", linetype = "dashed"),
                    panel.background = element_rect(fill = "white", colour = "black"),
                    legend.background = element_rect(fill="NA"),
                    legend.position = "bottom",
                    axis.text = element_text(size=12 + size_mod),
                    axis.title.x = element_text(size=15 + size_mod, vjust = -0.1), 
                    axis.title.y = element_text(size=15 + size_mod, vjust = 1),
                    strip.text = element_text(size=15 + size_mod, face = "bold"),
                    strip.background = element_rect(fill = "#9ecae1", colour = "black"),
                    legend.text = element_text(size=12 + size_mod), 
                    legend.title = element_text(size=15 + size_mod),
                    plot.title = element_text(size=20 + size_mod))

load("vig.RData")
```

dpcR is an R package designed to perform an analysis of digital PCR experiments. This manual covers topics most important in the usage of the package: `dpcr` object and its methods.

# `dpcr` object

The key class of dpcR package is `dpcr`. It has following slots:  
* *.Data* - matrix containing data from digital PCR runs (see '*.Data* slot' subsection). It is further specified by the *type* slot.  
* *n* - number of partitions read in each run.  
* *exper* - name of the experiment.  
* *replicate* - name (or more conviniently ID) of the replicate.  
* *assay* - name of the assay.  
* *type* - name of the data (see '*type* slot' subsection)  

This class is designed to contain results from all possible digital PCR experiments.

## `dpcr` objects managment (`bind_dpcr`, `extract_dpcr`)

All `dpcr` objects should be managed using special functions provided by the package: `bind_dpcr` and `extract_dpcr`. The former binds `dpcr` objects, the latter extracts parts of the `dpcr` object. It is important to use this functions, because they preserve other attributes importantant for `dpcr` objects as number of partitions, names of experiments, assays and technical replicates.

```{r eval=TRUE}
#create single adpcr object. The following code is also true for 
#other objects inhering from dpcr, as ddpcr or qdpcr
single_run <- sim_adpcr(m = 100, n = 765, times = 1000, pos_sums = FALSE, n_panels = 1)
two_runs <- bind_dpcr(single_run, single_run)
three_runs <- bind_dpcr(single_run, single_run, single_run)
#it is also possible to bind a list of dpcr objects... 
three_runs_list <- bind_dpcr(list(single_run, single_run, single_run))
#... which may be useful in do.call statements
dpcr_list <- do.call(bind_dpcr, lapply(5L:10*10, function(n_template)
  sim_adpcr(m = n_template, n = 765, times = 1000, pos_sums = FALSE, n_panels = 1)))
```

`bind_dpcr` may be seen as the analogue of the R function [cbind](https://stat.ethz.ch/R-manual/R-devel/library/base/html/cbind.html). The main difference is the lack of recycling. If two objects with uneven number of data points are bound together, the shorter is completed with NA values.

```{r eval=TRUE}
longer_run <- sim_adpcr(m = 10, n = 25, times = 1000, pos_sums = FALSE, n_panels = 1)
shorter_run <- sim_adpcr(m = 10, n = 20, times = 1000, pos_sums = FALSE, n_panels = 1)
shortest_run <- sim_adpcr(m = 10, n = 15, times = 1000, pos_sums = FALSE, n_panels = 1)
#expect informative message after binding
bind_dpcr(longer_run, shorter_run, shortest_run)
```

`extract_dpcr` is an equivalent of [Extract](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Extract.html). It extracts one or more runs from the `dpcr` objects preserving other properties (as an adequate replicate ID and so on).

```{r eval=TRUE}
five_runs <- sim_adpcr(m = 2, n = 10, times = 1000, pos_sums = FALSE, n_panels = 5)
print(five_runs)

#extract runs by the index
only_first_run <- extract_dpcr(five_runs, 1)
only_first_and_second_run <- extract_dpcr(five_runs, c(1, 2))
#see if proper replicated were extracted
slot(only_first_and_second_run, "replicate")
no_first_run <- extract_dpcr(five_runs, -1)
slot(no_first_run, "replicate")
#extract runs by the name
run_Experiment1.3 <- extract_dpcr(five_runs, "Experiment1.3")
slot(run_Experiment1.3, "replicate")
run_Experiment1.3and5 <- extract_dpcr(five_runs, c("Experiment1.3", "Experiment1.5"))
slot(run_Experiment1.3and5, "replicate")
```

Since the `dpcr` object *.Data* slot inherits from the matrix class, it is possible to also use normal *Extract* operator ('['). For more information about this topic, see '*.Data* slot' subsection.

## Read data

The `read_dpcr` function is responsible for importing data from external file sources into R working space. The additional parameters allow specification of the format type and other parameters.

Additionally, we advise using other packages belonging do the pcRuniversum such as [RDML](http://cran.r-project.org/package=RDML) or dedicated packages such as ReadqPCR ([available from bioconductor.org](http://www.bioconductor.org/packages/release/bioc/html/ReadqPCR.html)). Further information can be found in @pabinger_survey_2014.

```{r eval=TRUE}
#generate some data from 15x16 array. Let's presume, that we have results from two plates
sample_runs <- matrix(rpois(480, lambda = 1.5), ncol = 2)
#check its class - it's a typical R structure
class(sample_runs)
#save it to adpcr object
adpcr_experiments <- create_dpcr(sample_runs, n = c(240L, 240L), type = "nm", adpcr = TRUE)
class(adpcr_experiments)
```


## *.Data* slot

Digital PCR data is always a matrix (see `?matrix` in R). Columns and rows represent respectively individual runs and their data points. The data points are not equivalent to partitons. The number of partitions for each run is defined in slot *n*.  

```{r eval=TRUE}
#create two array digital PCR experiments. Mind the difference in the n parameter.
sample_adpcr <- bind_dpcr(sim_adpcr(m = 100, n = 765, times = 1000, pos_sums = FALSE, n_panels = 1), 
                          rename(sim_adpcr(m = 100, n = 763, times = 1000, pos_sums = FALSE, 
                                           n_panels = 1), 
                                 exper = "Experiment2"))
```

In the code chunk above we created two array digital PCR experiments with respectively 765 and 763 partitions. See the last five data points:

```{r eval=TRUE}
#it's possible to manipulate data points from dpcr object using all functions that work for matrices
tail(sample_adpcr)
```

Both experiments have 765 data points. We see that in case of shorter experiment, 2 data points has value NA. If we analyze the *n* slot:

```{r eval=TRUE}
slot(sample_adpcr, "n")
```

we see the expected number of partitions. It is especially important in case of fluorescence digital PCR data, where one droplet may have assigned few data points.

The important feature of *.Data* is inheritance from `matrix` class, which opens numerous possibilities for data manipulation. 
```{r eval=TRUE}
sample_data <- sim_adpcr(m = 5, n = 20, times = 1000, pos_sums = FALSE, n_panels = 2)
#quickly count positive partitions
colSums(sample_data > 0)
#baseline fluorescence data
bl_data <- sim_ddpcr(m = 3, n = 2, times = 5, fluo = list(0.1, 0)) - 0.05
```


## *type* slot

Data from digital PCR experiments may have several types:  
* `ct` (**c**ycle **t**hreshold): cycle threshold of each partition.  
* `fluo`: fluorescence intensity of each partition.  
* `nm` (**n**umber of **m**olecules): number of molecules in each partition (usually such exact data comes only from simulations).  
* `np` (**n**umber of **p**ositives): status (positive (1) or negative(0)) of each partition.  
* `tnp` (**t**otal **n**umber of **p**ositives): total number of positive partitions in the run (*.Data* in this case is matrix with single row and number of columns equal to the number of runs).  

```{r eval=TRUE}
#see all types of data

#ct
#load library with qPCR data
library(chipPCR)
qpcr2pp(data = C127EGHP[, 1L:6], type = "ct")

#fluo
head(sim_ddpcr(m = 3, n = 2, times = 5, fluo = list(0.1, 0)) - 0.05)

#nm
sim_adpcr(m = 5, n = 5, times = 1000, pos_sums = FALSE, n_panels = 3)

#np
binarize(sim_adpcr(m = 5, n = 5, times = 1000, pos_sums = FALSE, n_panels = 3))

#tnp
sim_adpcr(m = 5, n = 5, times = 1000, pos_sums = TRUE, n_panels = 3)
```

# Data visualisation

Data from digital PCR arrays can be easily visualized using `plot_panel` function.

```{r eval=TRUE}
#remember, you can plot only single panel at once 
plot_panel(extract_dpcr(adpcr_experiments, 1), main = "Experiment 1")
```

The same data can be visualized easily in binarized form (positive/negative partitions).
```{r eval=TRUE}
#remember, you can plot only single panel at once 
plot_panel(binarize(extract_dpcr(adpcr_experiments, 1)), main = "Experiment 1")
```

The `plot_panel` function returns invisibly coordinates, that are compatibile with graphics and ggplot packages.
```{r eval=TRUE}
#extract graphical coordinates
panel_data <- plot_panel(extract_dpcr(adpcr_experiments, 1), plot = FALSE)
ggplot_coords <- cbind(panel_data[["ggplot_coords"]], value = as.vector(extract_dpcr(adpcr_experiments, 1)))

#plot panel using different graphics package
library(ggplot2)
ggplot(ggplot_coords, aes(x = x, y = y, fill = value)) +
  geom_tile()

```


# Comparison of the experiments

## GLM

Generalized Linear Models (GLM) are linear models for data, where the response variables may have non-normal distributions (as for example binomially distributed positive partitions in digital PCR experiments). Using GLM we can describe relationships between results of digital PCR:
  
  $$\log{Y} = \beta^T X$$
  
  where $Y$ are counts, $X$ are experiments names (categorical data) and $\beta$ are linear model coefficients for every experiment. Moreover, $\exp{\beta} = \lambda$.

Estimated means copies per partitions obtained from the model are compared each other using multiple t-test.

```{r eval=TRUE}
#compare experiments using GLM
#set a random seed for simulations
set.seed(54321)

#1. Simulate results of three different experiments with two repetitions each
#experiment 2 differs significantly from others
adpcr1 <- sim_adpcr(m = 20, n = 765, times = 1e5, pos_sums = FALSE, n_panels = 2)
adpcr2 <- sim_adpcr(m = 130, n = 765, times = 1e5, pos_sums = FALSE, n_panels = 2)
adpcr2 <- rename(adpcr2, exper = "Experiment2")
adpcr3 <- sim_adpcr(m = 50, n = 765, times = 1e5, pos_sums = FALSE, n_panels = 2)
adpcr3 <- rename(adpcr3, exper = "Experiment3")
#2. Join results for convenience
adpcrs <- bind_dpcr(adpcr1, adpcr2, adpcr3)

#3. Perform test
comp <- test_counts(adpcrs)

#4. See summary of the test
summary(comp)

#5. Plot results of the test 
plot(comp, aggregate = FALSE)

#6. Aggregate runs to their groups
plot(comp, aggregate = TRUE)

#7. extract coefficients for the further usage
coef(comp)
```

The Poisson regression on binary data (positive/negative partition) can be used only when the concentration of template molecules in samples is small (positive partitions contain very rarely more than 1 template particle). Higher concentrations requires binomial regression.

## Multiple tests

The dPCR experimentes may be also compared pairwise using the uniformly most powerful (UMP) ratio test [@fay_2010]. Furthermore, computed p-values are adjusted using Benjamini & Hochberg correction [@benjamini_1995] to control family-wise error rate.

The UMP ratio test has following null-hypothesis:

$$
H_0: \frac{\lambda_1}{\lambda_2} = 1
$$

The generally adviced Wilson's confidence intervals [@brown_2001] are computed independently for every dPCR experiment. The confidence intervals are adjusted using Dunn -- &#352;id&#225;k correction to ensure that they simultaneously contain true value of $lambda$:

$$
\alpha_{\text{adj}} = 1 - (1 - \alpha)^\frac{1}{T}
$$

For example, the 0.95 significance levels means, that probability of the all real values being in the range of its respective confidence intervals is 0.95.

```{r eval=TRUE}
#1. Perform multiple test comparison using data from the previous example
comp_ratio <- test_counts(adpcrs, model = "ratio")

#2. See summary of the test
summary(comp_ratio)

#3. Plot results of the test 
plot(comp_ratio, aggregate = FALSE)

#4. Aggregate runs to their groups
plot(comp_ratio, aggregate = TRUE)

#5. extract coefficients for the further usage
coef(comp)

#compare results of two methods
par(mfrow=c(2,1))
plot(comp, aggregate = FALSE)
title("GLM")
plot(comp_ratio, aggregate = FALSE)
title("Ratio")
par(mfrow=c(1,1))


```


## Comparision of frameworks
Two approaches presented above were compared in a simulation approach over 150 000 simulated array dPCR experiments. Each simulation contained six reactions. Three of them had roughly the same amount of molecules per plate and other three had experiments with 10 to 50 molecules more.
Experiments were compared using GLM and MT frameworks.

```{r eval=TRUE,echo=FALSE}
ggplot(data=madpcr_comp,aes(x = value, fill = method)) +
  geom_density(alpha = 0.3) + 
  scale_fill_discrete("Confidence intervals:") + 
  scale_y_continuous("Density") + 
  scale_x_continuous("Fraction of wrongly assigned experiments") + 
  cool_theme
```

On average, 2.03 and 1.98 reactions were assessed to a wrong group by respectively GLM and MT.

A single GLM comparison took roughly 183 times longer than MT (on average 1.10 seconds versus 0.006 seconds on the Intel i7-2600 processor). The difference growths with the number of experiments and number of partitions (data not shown).


## Probability coverage of confidence intervals

  Average covarage probability is the proportion of the time that the interval contains the true value of $\lambda$.
  
  In the example below, we simulated 1\e{6} droplet dPCR experiments (2\e{4} droplets each) for each level of $\lambda$ (1.2\e{7} experiments total). We computed average probability coverage of CI obtained by three methods: Dube's[@dube_mathematical_2008], Bhat's[@bhat_single_2009] and by MT ($\alpha = 0.95$).
  
  To assess simultaneous coverage probability, we randomly divided experiments into 2000 groups (500 experiments each) for each possible value of $\lambda$. We counted frequency of groups in which all confidence intervals contain the true value of $\lambda$.
  
  
```{r eval=TRUE,echo=FALSE}
ggplot(m_coverage2, aes(x = prop, y = value, fill = method)) +
  geom_bar(stat="identity", position = "dodge") +
  scale_y_continuous("Probability coverage") + 
  scale_x_discrete(expression(lambda)) +
  scale_fill_discrete("Confidence intervals:") + 
  geom_hline(y = 0.95, colour = "black", size = 1, linetype = 5) +
  facet_wrap(~ coverage, nrow = 2) + 
  cool_theme
```

The dashed black line marks 0.95 border.

```{r eval=TRUE,echo=FALSE,results="asis"}
dat <- as.data.frame(aggregate(value ~ method + coverage, m_coverage2, mean))

colnames(dat) <- c("Method name", "Type of coverage", "Value")
print(xtable(dat), 
      include.rownames = FALSE, type = "html")
```
  
  
# References
